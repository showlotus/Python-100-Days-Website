import{_ as h,c as p,o as l,ag as n,j as i,a}from"./chunks/framework.CYgIfFH3.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Day01-20/17.函数高级应用.md","filePath":"Day01-20/17.函数高级应用.md","lastUpdated":1740374267000}'),e={name:"Day01-20/17.函数高级应用.md"},k={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},t={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.481ex"},xmlns:"http://www.w3.org/2000/svg",width:"15.916ex",height:"1.923ex",role:"img",focusable:"false",viewBox:"0 -637.5 7035 850","aria-hidden":"true"};function r(d,s,E,g,c,y){return l(),p("div",null,[s[10]||(s[10]=n("",22)),i("p",null,[s[2]||(s[2]=a("Python 中允许函数嵌套定义，也允许函数之间相互调用，而且一个函数还可以直接或间接的调用自身。函数自己调用自己称为递归调用，那么递归调用有什么用处呢？现实中，有很多问题的定义本身就是一个递归定义，例如我们之前讲到的阶乘，非负整数")),s[3]||(s[3]=i("code",null,"N",-1)),s[4]||(s[4]=a("的阶乘是")),s[5]||(s[5]=i("code",null,"N",-1)),s[6]||(s[6]=a("乘以")),s[7]||(s[7]=i("code",null,"N-1",-1)),s[8]||(s[8]=a("的阶乘，即 ")),i("mjx-container",k,[(l(),p("svg",t,s[0]||(s[0]=[n("",1)]))),s[1]||(s[1]=i("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("mstyle",{mathsize:"0.85em"},[i("mrow",{"data-mjx-texclass":"ORD"},[i("mi",null,"N"),i("mo",null,"!"),i("mo",null,"="),i("mi",null,"N"),i("mo",null,"×"),i("mo",{stretchy:"false"},"("),i("mi",null,"N"),i("mo",null,"−"),i("mn",null,"1"),i("mo",{stretchy:"false"},")"),i("mo",null,"!")])])])],-1))]),s[9]||(s[9]=a(" ，定义的左边和右边都出现了阶乘的概念，所以这是一个递归定义。既然如此，我们可以使用递归调用的方式来写一个求阶乘的函数，代码如下所示。"))]),s[11]||(s[11]=n("",14))])}const b=h(e,[["render",r]]);export{F as __pageData,b as default};
